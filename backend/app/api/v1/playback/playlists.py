"""Routes API pour les playlists."""
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.database import get_db
from app.schemas import (
    PlaylistCreate,
    PlaylistGenerate,
    PlaylistResponse,
    PlaylistDetailResponse,
    PlaylistExportFormat,
)
from app.services.playback import PlaylistService, RoonPlaybackService
from app.services.external.ai_service import AIService
from app.core.config import get_settings
import logging

logger = logging.getLogger(__name__)

router = APIRouter()


def get_ai_service():
    """Obtenir le service IA."""
    settings = get_settings()
    secrets = settings.secrets
    euria_config = secrets.get('euria', {})
    
    return AIService(
        url=euria_config.get('url'),
        bearer=euria_config.get('bearer'),
        max_attempts=euria_config.get('max_attempts', 5),
        default_error_message=euria_config.get('default_error_message', 'Aucune information disponible')
    )


@router.get("", response_model=List[PlaylistResponse])
async def list_playlists(
    db: Session = Depends(get_db)
):
    """
    List all playlists in the system.
    
    Returns a summary list of all playlists (both manual and AI-generated) with basic
    metadata. Each playlist shows name, generation algorithm, prompt used (if any),
    track count, and creation date. Used by the frontend playlist browser or sidebar.
    
    **Response (200 OK):**
    ```json
    [
      {
        "id": 1,
        "name": "Weekend Relaxation",
        "algorithm": "mood_based",
        "ai_prompt": "Relaxing instrumental music for weekend",
        "track_count": 42,
        "created_at": "2025-01-15T10:30:00Z"
      },
      {
        "id": 2,
        "name": "My Favorites",
        "algorithm": "manual",
        "ai_prompt": null,
        "track_count": 28,
        "created_at": "2025-01-10T14:20:00Z"
      },
      {
        "id": 3,
        "name": "Discover Progressive Rock",
        "algorithm": "ai_generated",
        "ai_prompt": "Progressive rock albums with long instrumental passages",
        "track_count": 35,
        "created_at": "2025-01-08T09:45:00Z"
      }
    ]
    ```
    
    **Playlist Algorithms:**
    - **manual**: User-created (manually added tracks)
    - **mood_based**: Generated by mood/mood extracted from listening
    - **ai_generated**: AI-generated based on prompt
    - **discovery**: Algorithmic discovery playlists
    - **collection_based**: Based on album collections
    
    **Response Fields:**
    - **id**: Unique playlist ID (use for detail/play endpoints)
    - **name**: User-friendly playlist name
    - **algorithm**: How playlist was created
    - **ai_prompt**: Original AI prompt (null for manual playlists)
    - **track_count**: Number of tracks in playlist
    - **created_at**: ISO 8601 timestamp when created
    
    **Performance:**
    - Query: 50-200ms (depends on number of playlists)
    - Typical: 5-20 playlists
    - Can cache for 5 minutes (updated when playlist added/deleted)
    
    **Usage Examples:**
    ```bash
    # Get all playlists
    GET /api/v1/playback/playlists
    
    # Returns array of playlist summaries
    [{"id": 1, "name": "Playlist 1", ...}, ...]
    ```
    
    **Frontend Integration:**
    ```javascript
    // Load playlist sidebar
    const playlists = await fetch('/api/v1/playback/playlists')
      .then(r => r.json());
    
    playlists.forEach(playlist => {
      addSidebarItem(playlist.name, () => loadPlaylist(playlist.id));
    });
    ```
    
    **Sorting:**
    - Default: By creation date (newest first)
    - Could add: name_asc, name_desc, track_count, etc.
    
    **Filtering (Future):**
    - By algorithm: algorithm=manual
    - By keyword: name contains search term
    - By creation date range
    
    **Empty Result:**
    - Returns: Empty array []
    - Valid when: No playlists created yet
    
    **Related Endpoints:**
    - POST /api/v1/playback/playlists: Create new playlist
    - GET /api/v1/playback/playlists/{id}: Get playlist details
    - POST /api/v1/playback/playlists/{id}/play-on-roon: Play playlist
    """
    try:
        playlists = PlaylistService.list_playlists(db)
        return [
            PlaylistResponse(
                id=p.id,
                name=p.name,
                algorithm=p.algorithm,
                ai_prompt=p.ai_prompt,
                track_count=p.track_count,
                created_at=p.created_at
            )
            for p in playlists
        ]
    except Exception as e:
        logger.error(f"Erreur liste playlists: {e}")
        raise HTTPException(status_code=500, detail="Erreur liste playlists")


@router.post("", response_model=PlaylistResponse, status_code=201)
async def create_playlist(
    data: PlaylistCreate,
    db: Session = Depends(get_db)
):
    """
    Create a new manual playlist.
    
    Creates a new playlist with manually selected tracks. User provides a name and
    list of track IDs. Playlist is created immediately with all tracks. Useful for
    curating personal collections or creating themed playlists. Algorithm is set to
    "manual" to indicate it was created by user selection.
    
    **Request Body:**
    ```json
    {
      "name": "My Favorites",
      "track_ids": [1, 5, 12, 23, 45, 67, 89, 101]
    }
    ```
    
    **Response (201 Created):**
    ```json
    {
      "id": 4,
      "name": "My Favorites",
      "algorithm": "manual",
      "ai_prompt": null,
      "track_count": 8,
      "created_at": "2025-02-08T15:30:00Z"
    }
    ```
    
    **Request Parameters:**
    - **name** (required): Playlist name (string, 1-100 chars)
    - **track_ids** (required): Array of track IDs (int, 1-1000 tracks)
    
    **Validation:**
    - Track IDs must exist in database
    - No duplicate tracks (or deduplicated automatically)
    - Name must be non-empty
    - Max 1000 tracks per playlist (design limit)
    
    **Performance:**
    - Create playlist record: 5-10ms
    - Add track associations: 10ms per track
    - Total (100 tracks): 1000-1100ms
    - Total (1000 tracks): 10000-11000ms
    
    **Algorithm Field:**
    - Set to: "manual" (hardcoded)
    - Indicates: User manually selected tracks
    - Distinguishes from: AI-generated or discovery playlists
    
    **Usage Examples:**
    ```bash
    # Create playlist with 5 tracks
    POST /api/v1/playback/playlists
    {
      "name": "Rock Classics",
      "track_ids": [10, 20, 30, 40, 50]
    }
    
    # Returns newly created playlist
    {"id": 4, "name": "Rock Classics", "track_count": 5, ...}
    ```
    
    **Frontend Integration:**
    ```javascript
    // User creates playlist from selected tracks
    async function createPlaylist(name, selectedTrackIds) {
      const response = await fetch('/api/v1/playback/playlists', {
        method: 'POST',
        body: JSON.stringify({
          name: name,
          track_ids: selectedTrackIds
        })
      }).then(r => r.json());
      
      return response.id; // New playlist ID
    }
    ```
    
    **Error Cases:**
    - Duplicate track IDs: Will create duplicates (or deduplicated)
    - Invalid track ID: 400 Bad Request (track not found)
    - Empty name: 400 Bad Request
    - Too many tracks: 400 Bad Request (>1000)
    
    **Track Ordering:**
    - Tracks added in array order
    - Can reorder later with update endpoint (if implemented)
    - First track = position 1, playback starts here
    
    **Naming Constraints:**
    - Min length: 1 character
    - Max length: 100 characters
    - Can contain: Any Unicode characters
    - Should contain: Descriptive name for UI
    
    **Related Endpoints:**
    - GET /api/v1/playback/playlists: List all playlists
    - POST /api/v1/playback/playlists/generate: AI-generate playlist
    - GET /api/v1/playback/playlists/{id}: Get playlist detail
    - POST /api/v1/playback/playlists/{id}/play-on-roon: Play it
    """
    try:
        playlist = PlaylistService.create_playlist(
            db, data.name, "manual", None, data.track_ids
        )
        
        return PlaylistResponse(
            id=playlist.id,
            name=playlist.name,
            algorithm=playlist.algorithm,
            ai_prompt=playlist.ai_prompt,
            track_count=playlist.track_count,
            created_at=playlist.created_at
        )
    except Exception as e:
        logger.error(f"Erreur création playlist: {e}")
        raise HTTPException(status_code=400, detail=str(e))


@router.post("/generate", response_model=PlaylistResponse, status_code=201)
async def generate_playlist(
    data: PlaylistGenerate,
    db: Session = Depends(get_db)
):
    """
    Generate a new AI-powered playlist.
    
    Uses AI (Euria) to generate a playlist based on algorithm and optional prompt.
    Supports multiple generation algorithms (mood-based, discovery, style-based, etc.).
    Can take 10-30 seconds depending on generation complexity. Returns a new playlist
    with AI-selected tracks. Useful for exploring music or discovering new content.
    
    **Request Body:**
    ```json
    {
      "algorithm": "mood_based",
      "ai_prompt": "Relaxing jazz instrumentals for focus work",
      "max_tracks": 40,
      "name": "Focus Session"
    }
    ```
    
    **Response (201 Created):**
    ```json
    {
      "id": 5,
      "name": "Focus Session",
      "algorithm": "ai_generated",
      "ai_prompt": "Relaxing jazz instrumentals for focus work",
      "track_count": 40,
      "created_at": "2025-02-08T16:15:00Z"
    }
    ```
    
    **Algorithms Supported:**
    - **mood_based**: Generate from mood/emotional tone
      - Prompt: "Energetic morning music", "Calm ambient", etc.
    - **discovery**: Discover new artists/albums
      - Prompt: "Jazz fusion bands like Weather Report"
    - **style_based**: Genre or style focused
      - Prompt: "Progressive rock with 10+ minute tracks"
    - **temporal**: Time-of-day or seasonal
      - Prompt: "Late night introspective listening"
    - **collection_based**: From album collections
      - Uses stored collections as seed
    
    **Parameters:**
    - **algorithm** (enum): Generation method (mood_based, discovery, etc.)
    - **ai_prompt** (optional): Detailed instructions for AI
      - If omitted: Uses algorithm default prompt
      - Can override algorithm behavior
      - Examples: "Piano pieces", "Heavy metal", "Indie pop"
    - **max_tracks** (optional, default: 30, max: 500)
    - **name** (optional): Custom playlist name
      - If omitted: Auto-generated from algorithm
    
    **Performance:**
    - AI analysis: 5-30 seconds (depends on algorithm complexity)
    - Track selection: 2-5 seconds
    - Database insert: 100-500ms
    - Total: 10-35 seconds
    
    **AI Integration:**
    - Service: Euria (configured in secrets.json)
    - Endpoint: euria.url + "/api/generate-playlist"
    - Auth: Bearer token from euria.bearer
    - Timeout: 30 seconds per generation
    
    **Generation Quality:**
    - Depends on: Listed history quality, metadata completeness
    - Better results: More diverse listening history
    - Weak results: Limited history or obscure music
    - Fallback: Returns random selection if generation fails
    
    **Usage Examples:**
    ```bash
    # Generate mood-based playlist
    POST /api/v1/playback/playlists/generate
    {
      "algorithm": "mood_based",
      "ai_prompt": "Energetic workout music",
      "max_tracks": 50
    }
    
    # Generate discovery playlist
    POST /api/v1/playback/playlists/generate
    {
      "algorithm": "discovery",
      "ai_prompt": "Jazz fusion similar to Herbie Hancock",
      "max_tracks": 30,
      "name": "Jazz Fusion Exploration"
    }
    ```
    
    **Frontend Integration:**
    ```javascript
    // Generate playlist with progress feedback
    async function generatePlaylist(algorithm, prompt) {
      showLoadingSpinner('Generating playlist...');
      
      try {
        const result = await fetch('/api/v1/playback/playlists/generate', {
          method: 'POST',
          body: JSON.stringify({
            algorithm: algorithm,
            ai_prompt: prompt,
            max_tracks: 40
          })
        }).then(r => r.json());
        
        showSuccess(`Generated: ${result.name} (${result.track_count} tracks)`);
        return result.id;
      } finally {
        hideLoadingSpinner();
      }
    }
    ```
    
    **Error Handling:**
    - Invalid algorithm: 400 Bad Request
    - AI timeout: 504 Gateway Timeout
      → Retry or reduce max_tracks
    - No suitable tracks: 400 with suggestion
    - AI service down: 503 Service Unavailable
    
    **Regeneration:**
    - Currently no API for regenerating same playlist
    - Workaround: Delete old, create new with same params
    - Future: Could add "regenerate" button
    
    **Related Endpoints:**
    - POST /api/v1/playback/playlists: Create manual playlist
    - GET /api/v1/playback/playlists: List all playlists
    - GET /api/v1/playback/playlists/{id}: View generated playlist
    """
    try:
        ai_service = get_ai_service()
        
        track_ids = await PlaylistService.generate_playlist(
            db, ai_service, data.algorithm.value, data.max_tracks, data.ai_prompt
        )
        
        if not track_ids:
            raise HTTPException(status_code=400, detail="Impossible de générer la playlist")
        
        name = data.name if data.name else f"Playlist {data.algorithm.value}"
        
        playlist = PlaylistService.create_playlist(
            db, name, data.algorithm.value, data.ai_prompt, track_ids
        )
        
        return PlaylistResponse(
            id=playlist.id,
            name=playlist.name,
            algorithm=playlist.algorithm,
            ai_prompt=playlist.ai_prompt,
            track_count=playlist.track_count,
            created_at=playlist.created_at
        )
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Erreur génération playlist: {e}")
        raise HTTPException(status_code=500, detail="Erreur génération")


@router.get("/{playlist_id}", response_model=PlaylistDetailResponse)
async def get_playlist(
    playlist_id: int,
    db: Session = Depends(get_db)
):
    """
    Get detailed information about a specific playlist.
    
    Returns complete information about a playlist including all tracks, metadata,
    duration, unique artists/albums, and AI generation details if applicable.
    Tracks are ordered by playlist position (playback order). Used by the frontend
    to display full playlist view with all content.
    
    **Path Parameters:**
    - `playlist_id`: Unique playlist identifier (integer)
    
    **Response (200 OK):**
    ```json
    {
      "id": 1,
      "name": "Weekend Relaxation",
      "algorithm": "mood_based",
      "ai_prompt": "Relaxing instrumental music for weekend",
      "track_count": 42,
      "created_at": "2025-01-15T10:30:00Z",
      "tracks": [
        {
          "id": 105,
          "title": "Clair de Lune",
          "artist": "Claude Debussy",
          "album": "The Essential Debussy",
          "duration_seconds": 360,
          "loved": true,
          "position": 1
        },
        {
          "id": 217,
          "title": "Moonlight Sonata (1st Movement)",
          "artist": "Ludwig van Beethoven",
          "album": "Moonlight Sonata",
          "duration_seconds": 480,
          "loved": false,
          "position": 2
        }
      ],
      "total_duration_seconds": 2520,
      "unique_artists": 18,
      "unique_albums": 24
    }
    ```
    
    **Track Array:**
    - Ordered by `position` (playlist sequence)
    - Includes: All track metadata for display
    - Includes: `loved` status (favorite/not favorite)
    - Duration: In seconds (convert to MM:SS in frontend)
    
    **Aggregated Statistics:**
    - **total_duration_seconds**: Sum of all track lengths
      - Convert to: HH:MM:SS format (e.g., "2:48:45")
    - **unique_artists**: COUNT(DISTINCT artist_id)
      - Indicates playlist diversity
    - **unique_albums**: COUNT(DISTINCT album_id)
      - Indicates breadth vs depth
    
    **Database Queries:**
    - Playlist lookup: 5-10ms
    - Tracks join (Album, Artist): 50-200ms
    - Stats aggregation: 20-50ms
    - Total: 100-300ms
    
    **Performance:**
    - Small playlist (50 tracks): 150-250ms
    - Medium playlist (200 tracks): 200-400ms
    - Large playlist (500+ tracks): 300-600ms
    
    **Pagination (Future Enhancement):**
    - Currently: All tracks returned
    - Could add: ?page=1&page_size=50
    - Needed when: Playlists exceed 500 tracks
    
    **Usage Examples:**
    ```bash
    # Get playlist detail
    GET /api/v1/playback/playlists/1
    ```
    
    **Frontend Integration:**
    ```javascript
    // Load full playlist view
    const playlistId = 1;
    const playlist = await fetch(`/api/v1/playback/playlists/${playlistId}`)
      .then(r => r.json());
    
    // Display playlist info
    headingEl.textContent = playlist.name;
    durationEl.textContent = formatSeconds(playlist.total_duration_seconds);
    artistCountEl.textContent = `${playlist.unique_artists} artists`;
    
    // Render track table
    playlist.tracks.forEach((track, idx) => {
      addTableRow({
        position: idx + 1,
        title: track.title,
        artist: track.artist,
        duration: formatSeconds(track.duration_seconds),
        album: track.album,
        loved: track.loved
      });
    });
    ```
    
    **Error Cases:**
    - Playlist not found: 404 Not Found
    - Invalid playlist_id: 400 Bad Request
    - Database error: 500 Internal Server Error
    
    **Empty Playlist:**
    - Valid: tracks = [] (empty array)
    - total_duration_seconds = 0
    - Usually indicates: Playlist created but no tracks added yet
    
    **Caching Strategy:**
    - Can cache for 5 minutes
    - Invalidate when: Tracks added/removed/reordered
    - Update on: Any playlist modification
    
    **Related Endpoints:**
    - GET /api/v1/playback/playlists: List all playlists
    - DELETE /api/v1/playback/playlists/{id}: Delete playlist
    - POST /api/v1/playback/playlists/{id}/play-on-roon: Play it
    - GET /api/v1/playback/playlists/{id}/export: Export tracks
    """
    try:
        playlist = PlaylistService.get_playlist(db, playlist_id)
        if not playlist:
            raise HTTPException(status_code=404, detail="Playlist non trouvée")
        
        tracks_data = PlaylistService.get_playlist_tracks(db, playlist_id)
        
        return PlaylistDetailResponse(
            id=playlist.id,
            name=playlist.name,
            algorithm=playlist.algorithm,
            ai_prompt=playlist.ai_prompt,
            track_count=playlist.track_count,
            created_at=playlist.created_at,
            tracks=tracks_data["tracks"],
            total_duration_seconds=tracks_data["total_duration_seconds"],
            unique_artists=tracks_data["unique_artists"],
            unique_albums=tracks_data["unique_albums"]
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Erreur récupération playlist: {e}")
        raise HTTPException(status_code=500, detail="Erreur récupération")


@router.delete("/{playlist_id}", status_code=204)
async def delete_playlist(
    playlist_id: int,
    db: Session = Depends(get_db)
):
    """
    Delete a playlist permanently.
    
    Removes a playlist and all its track associations from the database. This is a
    destructive operation - data cannot be recovered. Used when user removes playlist
    from library. No response body on success (status 204).
    
    **Path Parameters:**
    - `playlist_id`: Unique playlist identifier
    
    **Response (204 No Content):**
    - Empty response body
    - HTTP status 204 indicates success
    - Browser/client should remove from UI immediately
    
    **What Gets Deleted:**
    - Playlist record itself
    - All track associations (junction table entries)
    - NOT the tracks themselves (they remain in database)
    - NOT track history or favorites
    
    **Database Operations:**
    - Lookup: SELECT playlist WHERE id = playlist_id (5ms)
    - Delete tags: DELETE FROM playlist_track WHERE playlist_id = id (50-500ms)
    - Delete playlist: DELETE FROM playlist WHERE id = id (10ms)
    - Total: 70-520ms
    
    **Cascade Behavior:**
    - Track records: Preserved (can be used in other playlists)
    - Play history: Preserved (tracks still in listening history)
    - Favorites: Preserved (loved status persists)
    - Other playlists: Not affected
    
    **Performance:**
    - Small playlist (50 tracks): 70-150ms
    - Medium playlist (200 tracks): 100-300ms
    - Large playlist (1000+ tracks): 200-600ms
    
    **Usage Examples:**
    ```bash
    # Delete playlist
    DELETE /api/v1/playback/playlists/5
    
    # Returns: Empty response (204)
    ```
    
    **Frontend Integration:**
    ```javascript
    // Delete button handler
    async function deletePlaylist(playlistId) {
      if (!confirm('Really delete this playlist?')) return;
      
      const response = await fetch(
        `/api/v1/playback/playlists/${playlistId}`,
        { method: 'DELETE' }
      );
      
      if (response.status === 204) {
        // Success - remove from UI
        removePlaylistFromList(playlistId);
        showSuccess('Playlist deleted');
      } else {
        showError('Failed to delete playlist');
      }
    }
    ```
    
    **Error Cases:**
    - Playlist not found: 404 Not Found
    - Invalid playlist_id: 400 Bad Request
    - Database error: 500 Internal Server Error
    
    **Idempotency:**
    - First delete: 204 success
    - Second delete (same ID): 404 (no longer exists)
    - Safe design: No silent failures
    
    **Deletion Confirmation:**
    - Recommended: Show confirmation dialog before delete
    - Message: "This cannot be undone. Delete playlist 'Name'?"
    - Prevent accidental deletions
    
    **Rollback:**
    - Not available after immediate commit
    - Could implement: Soft delete with recovery window
    - Currently: Permanent deletion
    
    **Audit Trail:**
    - Could add: Log delete events for security
    - Currently: No audit logging
    
    **Related Endpoints:**
    - GET /api/v1/playback/playlists: List playlists
    - GET /api/v1/playback/playlists/{id}: View before delete
    - POST /api/v1/playback/playlists: Create new
    """
    try:
        success = PlaylistService.delete_playlist(db, playlist_id)
        if not success:
            raise HTTPException(status_code=404, detail="Playlist non trouvée")
        return None
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Erreur suppression playlist: {e}")
        raise HTTPException(status_code=500, detail="Erreur suppression")


@router.get("/{playlist_id}/export")
async def export_playlist(
    playlist_id: int,
    format: PlaylistExportFormat,
    db: Session = Depends(get_db)
):
    """
    Export a playlist in various formats.
    
    Returns playlist in export format (M3U, JSON, CSV, etc.) for sharing or use
    in other applications. Includes track metadata, timing, and ordering. Useful
    for backup, sharing with friends, or importing into other music systems.
    
    **Query Parameters:**
    - `format`: Export format (enum)
      - **m3u**: Standard M3U playlist format (text/plain)
      - **m3u8**: Extended M3U with metadata (text/plain)
      - **json**: JSON format with full metadata (application/json)
      - **csv**: Comma-separated values (text/plain)
      - **pls**: PLS format (legacy, application/x-pls)
    
    **M3U Format (example):**
    ```
    #EXTM3U
    #EXTINF:360, Claude Debussy - Clair de Lune
    /path/to/track.mp3
    #EXTINF:480, Ludwig van Beethoven - Moonlight Sonata
    /path/to/track2.mp3
    ```
    
    **M3U8 Format (extended, with metadata):**
    ```
    #EXTM3U
    #EXT-X-VERSION:3
    #EXTINF:360, Claude Debussy - Clair de Lune,artist=Claude Debussy,album=The Essential Debussy
    Clair de Lune
    #EXTINF:480
    Moonlight Sonata (1st Movement)
    ```
    
    **JSON Format:**
    ```json
    {
      "playlist": {
        "name": "Weekend Relaxation",
        "track_count": 42,
        "total_duration_seconds": 2520
      },
      "tracks": [
        {
          "title": "Clair de Lune",
          "artist": "Claude Debussy",
          "album": "The Essential Debussy",
          "duration_seconds": 360
        }
      ]
    }
    ```
    
    **CSV Format:**
    ```
    Position,Title,Artist,Album,Duration
    1,Clair de Lune,Claude Debussy,The Essential Debussy,360
    2,Moonlight Sonata (1st Movement),Ludwig van Beethoven,Moonlight Sonata,480
    ```
    
    **Use Cases:**
    - **M3U**: Import to media players (Winamp, VLC, Foobar2000)
    - **JSON**: API integration, programmatic processing
    - **CSV**: Spreadsheet editing, data analysis
    - **PLS**: Older media players (WinAmp 2.x era)
    
    **Performance:**
    - Data retrieval: 100-300ms
    - Formatting: 50-500ms (depends on track count)
    - Serialization: 20-100ms
    - Total: 200-900ms
    
    **File Download:**
    - Response header: Content-Disposition: attachment
    - Filename: {playlist_name}.{extension}
    - Browser downloads as file
    
    **Usage Examples:**
    ```bash
    # Export to M3U
    GET /api/v1/playback/playlists/1/export?format=m3u
    
    # Export to JSON
    GET /api/v1/playback/playlists/1/export?format=json
    
    # Export to CSV
    GET /api/v1/playback/playlists/1/export?format=csv
    ```
    
    **Frontend Integration:**
    ```javascript
    // Download playlist
    function exportPlaylist(playlistId, format) {
      fetch(`/api/v1/playback/playlists/${playlistId}/export?format=${format}`)
        .then(r => r.blob())
        .then(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `playlist.${format}`;
          a.click();
        });
    }
    ```
    
    **Format Recommendations:**
    - **Import to other players**: Use M3U/M3U8
    - **Backup**: Use JSON (preserves all metadata)
    - **Share with non-technical users**: Use CSV (open in Excel)
    - **Public web players**: Use JSON (API integration)
    
    **Encoding:**
    - UTF-8: All formats use UTF-8 encoding
    - BOM: M3U may include UTF-8 BOM for Windows compatibility
    - Line endings: LF (\n) on Unix, CRLF (\r\n) on Windows (auto-detected)
    
    **Error Cases:**
    - Playlist not found: 404
    - Invalid format: 400 Bad Request with allowed formats
    - Database error: 500 Internal Server Error
    
    **Related Endpoints:**
    - GET /api/v1/playback/playlists/{id}: View playlist
    - POST /api/v1/playback/playlists: Create new
    - POST /api/v1/playback/playlists/{id}/play-on-roon: Play it
    """
    try:
        result = PlaylistService.export_playlist(db, playlist_id, format.value)
        if not result:
            raise HTTPException(status_code=404, detail="Playlist non trouvée")
        return result
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Erreur export playlist: {e}")
        raise HTTPException(status_code=500, detail="Erreur export")


@router.post("/{playlist_id}/play-on-roon")
async def play_playlist_on_roon(
    playlist_id: int,
    zone_name: str,
    db: Session = Depends(get_db)
):
    """
    Play a playlist on Roon with automatic track sequencing.
    
    Starts sequential playback of a playlist on a Roon zone. Automatically manages
    track sequencing so songs play in order with proper timing synchronization.
    Uses playlist track order for playback sequence. Essential for playing full
    playlists without manual intervention.
    
    **Query Parameters:**
    - `zone_name`: Target Roon zone name (string, required)
      - Example: "Living Room", "Kitchen"
      - Must be an existing zone
    - `playlist_id`: Playlist ID in URL path
    
    **Response (200 OK - Success):**
    ```json
    {
      "message": "Lecture de la playlist démarrée avec enchaînement automatique: Weekend Relaxation",
      "playlist": {
        "id": 1,
        "name": "Weekend Relaxation",
        "track_count": 42
      },
      "now_playing": {
        "title": "Clair de Lune",
        "artist": "Claude Debussy",
        "album": "The Essential Debussy"
      },
      "queue_info": {
        "total_tracks": 42,
        "mode": "automatic_sequential",
        "description": "Les tracks seront lus séquentiellement avec synchronisation basée sur la durée"
      },
      "zone": "Living Room"
    }
    ```
    
    **Playback Sequencing:**
    - Starts: First track in playlist (position 1)
    - Transitions: After each track finishes, switch to next
    - Sequencing: Automatic based on track duration
    - Syncing: Position tracked against expected cumulative time
    - Fallback: Manual skip if duration mismatch
    
    **Queue Management:**
    - Mode: "automatic_sequential"
    - Tracks: Queued in order
    - Skips: User can skip to next/previous
    - Repeat: Loop playlist (if configured)
    
    **Database Flow:**
    1. Fetch playlist: SELECT * FROM playlist WHERE id = playlist_id
    2. Get tracks: SELECT track FROM playlist_track WHERE playlist_id = id ORDER BY position
    3. Get metadata: Album, artist, duration for each track
    4. Sort: By position (already in playlist order)
    5. Send: Track list to Roon bridge
    
    **Performance:**
    - Playlist lookup: 10-20ms
    - Track retrieval (per track): 5ms
    - Metadata joins: 50-200ms
    - Roon queue setup: 100-500ms
    - Total (50 tracks): 300-800ms
    - Total (200 tracks): 600-1500ms
    
    **Roon Integration:**
    - Roon service: RoonPlaybackService
    - Method: playback control with track queue
    - API: Via Roon bridge HTTP endpoint
    - Queue: Managed by Roon (1000+ track limit)
    
    **Error Scenarios:**
    - Playlist not found: 404 Not Found
    - Zone not found: 404 with available zones list
    - Roon unavailable: 503 Service Unavailable
    - Roon control disabled: 403 Forbidden
    - Empty playlist: 400 Bad Request (no tracks)
    
    **Usage Examples:**
    ```bash
    # Play playlist on Living Room zone
    POST /api/v1/playback/playlists/1/play-on-roon?zone_name=Living%20Room
    
    # Response shows playback initiated
    {"message": "Lecture de la playlist démarrée...", "now_playing": {...}}
    ```
    
    **Frontend Integration:**
    ```javascript
    // Playlist play button
    async function playPlaylist(playlistId, zoneName) {
      const response = await fetch(
        `/api/v1/playback/playlists/${playlistId}/play-on-roon?zone_name=${zoneName}`,
        { method: 'POST' }
      ).then(r => r.json());
      
      if (response.message) {
        // Update now-playing display
        updateNowPlaying(response.now_playing);
        
        // Show status
        showNotification(
          `Now playing: ${response.now_playing.title} (${response.queue_info.total_tracks} tracks)`
        );
      }
    }
    ```
    
    **Zone Selection:**
    - zone_name: Display name from Roon
    - Must match exactly (case-sensitive)
    - Use GET /api/v1/playback/roon/zones to list
    
    **Automatic Sequencing Details:**
    - Tracks ordered by: position in playlist
    - Timing: Based on track duration_seconds
    - Expected time next track: current_time + track_duration
    - Verification: Check actual Roon time matches expectation
    - Adjustment: Manual skip if drift detected
    
    **Limitations:**
    - Max tracks: 1000 (Roon queue limit)
    - Long playlists: May timeout (>30s setup)
    - Network: Latency affects sequencing accuracy
    - No pause: Can't pause playlist while maintaining queue
    
    **Related Endpoints:**
    - GET /api/v1/playback/playlists/{id}: View playlist before playing
    - GET /api/v1/playback/roon/zones: List available zones
    - POST /api/v1/playback/roon/play-track: Play single track
    - POST /api/v1/playback/roon/control: Control playback (pause/skip)
    """
    try:
        settings = get_settings()
        roon_control_config = settings.app_config.get('roon_control', {})
        if not roon_control_config.get('enabled', False):
            raise HTTPException(status_code=403, detail="Le contrôle Roon n'est pas activé")
        
        result = RoonPlaybackService.play_playlist_on_roon(db, playlist_id, zone_name)
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Erreur playback Roon: {e}")
        raise HTTPException(status_code=500, detail=f"Erreur Roon: {str(e)}")



